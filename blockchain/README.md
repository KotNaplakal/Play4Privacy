# Role of the Blockchain

The Blockchain serves the following purposes in this project:  
* persisting the history of played games (hash representing it)
* payout of PLAY tokens to players
* donation collection (ETH) and distribution of extra PLAY tokens to donors

## Environment

In order to keep the entry barrier low, the application needed to be fully functional in a normal (not Ethereum aware) browser.  
The main interaction with the Blockchain is thus handled by the game server, based on cryptographically signed messages from players. 

## Game history

Game states are recorded, condensed to a hash and written to the Blockchain. The state consists primarily of all moves voted by players, signed with the Ethereum identity the client application created for them.
Initially that was meant to be done automatically after every game played via the `P4PGame` contract.  
Since not all needed logic was finished in a timely manner, a dedicated contract `P4PState` was later deployed for that. It allowed to persist the state hashes of all games batched into a single transaction, using the [stateless contract](https://medium.com/@childsmaidment/stateless-smart-contracts-21830b0cd1b6) pattern. In this pattern, nothing is stored in contract storage since the data is already in the Blockchain (as transaction parameters) anyway.  
The logic for state recording, processing and publishing can be found in `src/utilities` of this repository.    
The raw state is published to IPFS (more details [here](https://medium.com/play4privacy/hiding-ethereum-and-ipfs-under-the-hood-ca3b638e9636)).

# Contracts

## PlayToken

PLAY is an ERC20 token with the following properties
* mint() function for assigment of newly created tokens, callable only by a *controller* address
* updateable *controller* (because the control logic was not finalzed when deployed) with possibility to lock it
* doesn't allow sending to address 0x0 (prevent token holders from burning their tokens by accident)
* Implements withdrawTokens() in order to make other tokens sent to that address by accident recoverable
* Implemens approve() and transferFrom() - although that mechanism has a weakness, as descibed [here](https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view)
* Implements approveAndCall()

## P4PPool

Implements *phases*:  
initially, ETH donations are collected, then the game is played, then there's another donation phase and finally donations and tokens are payed out.  
The donation receiver was not pre-determined, thus a timelock allowing to set the receiver before making payout possible was implemented. That way, the owner contract got the possibility to never actually gain control over donated funds. Again, a set/lock mechanism was implented for the donation address. The timelock could always be updated to a date further in the future.  
PLAY tokens owned by this contract are assigned to donators (via withdraw pattern) with round 1 donators getting twice as many tokens per ETH. The ratio between ETH and PLAY is calculated on closing of the 2nd donation round. 

## P4PGame

P4PGame is the final version, P4PGameV1 and P4PGameV2 were only briefly in use due to design changes.  
This contract connects the Token and Pool contract in the following way:
* As controller of the token contract, it has exclusive permissions to mint tokens
* For every token generated by a player, an additional token is assigned to the pool
* Token distribution is done batched (multiple tokens to multiple players per transaction) with the caller (game server) responsible to not exceed the block gas limit
The possibility to persist game states with this contract was not used.

## P4PState

Used as a dummy contract to which the transaction containing the game states was addressed.

## P4PDonationSplitter

Once donation receivers and their addresses were known, this contract was deployed and registered as donationReceiver with the Pool contract.    
It contains only a fallback function allowing incoming ETH and a payout function forwarding its funds to the hardcoded donation receivers (50/50 split).  

# Setup

## How to run

Needs truffle and testrpc installed: `npm install -g truffle ethereumjs-testrpc`  
(Note that truffle has switched to another testnet implementation, this was not tested. Also, some of the following commands may have changed)
Start testrpc: `truffle-testrpc`  
Then, in another tab run `./contract-changed.sh` for applying changes to the contract code.

## How to test

* Start testrpc: `truffle-testrpc`
* Deploy the contracts: `truffle migrate`
* Run tests: `truffle test`

Note that a nodejs version with async/await support is required. Tested with v8.4.0.

Tests are supposed to run on testrpc. If run on a public testnet, a lot of tests will fail because failed transactions don't trigger Promise rejections (as is needed for some test cases to succeed).  
Could be fixed by adding an assertion checking the transaction return code (which wasn't available when this code was written - that possibility was introduced with Ethereum Metropolis).

## Mainnet

Contract addresses on mainnet:

* Owner: 0xFe4E89f620a8663d03136bee040904fe3A623f5D
* Token address: 0xfB41f7b63c8e84f4BA1eCD4D393fd9daa5d14D61
* Game address: 0x78Cb0dB58721596Bc79Dc9D8d8296212D153D804, V2: 0x2A8A3008d7f2ba87fd339941E362FC9FBD9A1B57 (V1 was: 0x8d9a49dCc42E365D9Cd353b5AeF88eBe664C11a6)
* Pool address: 0x7e0C7676be340EE8eFB4321abfA4634a7Abfb92c
* State address: 0x762e90ffae540d56c428b472326de71ef0c8b5fe
* DonationSplitter address: 0xBA4d3d192C766C61A485f378e96be77701332BF2
* Dev donation addr: 0x57f81fa922527198c9e8d4ac3a98971a8c46e7e2

### Gas

The minimal gas price required to get transactions through in few minutes recently can fluctuate considerably.      
http://ethgasstation.info/ provides quite up to date and accurate info.

In order to re-broadcast a stuck transaction with higher gas price, do:  
```
badTx = web3.eth.pendingTransactions[<index>]
badTx.data = badTx.input
badTx.gasPrice = <new gas price>
web3.eth.sendTransaction(badTx)
```
source: https://ethereum.stackexchange.com/questions/9374/geth-can-not-resend-transaction-transaction-not-found

## Truffle

Truffle has it peculiarities, but is quite useful.  
I couldn't figure out how to chain multiple deploys in a single migration file when using await/async.

After some issues and due to a lack of understanding of the inner workings, I decided not to use the migration mechanism on mainnet, but instead manually deploy via truffle console.  
The manual commands were:
```
tokenAddress = "0xfb41f7b63c8e84f4ba1ecd4d393fd9daa5d14d61"
P4PGame.new(tokenAddress)
P4PPool.new(tokenAddress)
game = P4PGame.at("0x2A8A3008d7f2ba87fd339941E362FC9FBD9A1B57")
game.setPoolContract("0x7e0C7676be340EE8eFB4321abfA4634a7Abfb92c", {gas: 30000})
# failed with out of gas :-(
gameV1 = P4PGameV1.at("0x8d9a49dCc42E365D9Cd353b5AeF88eBe664C11a6")
gameV1.setTokenController("0x2A8A3008d7f2ba87fd339941E362FC9FBD9A1B57")
game.setPoolContract("0x7e0C7676be340EE8eFB4321abfA4634a7Abfb92c", {gas: 30000})
# ... analog for P4PState and P4PDonationSplitter
```